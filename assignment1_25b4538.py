# -*- coding: utf-8 -*-
"""Assignment1_25b4538.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15q7nP6KKu0WIyKoDsDcS71F8dVeqD7CG

## Week-1 Assignment
Fill the missing places wherever TO DO is mentioned and also understnad what has been done properly

Also report :
- Asset with highest expected return:
- Asset with highest volatility:
- If there is any negatively correlated pairs (corr < -0.1) and if yes also mention which are they

Do not use Chatgpt . It is a simple assignment. Make a copy of this colab notebook and do your changes and submit it as `Assignment1_yourrollno.ipnyb`
"""

import pandas as pd
import numpy as np
import yfinance as yf
import matplotlib.pyplot as plt
import seaborn as sns
from math import sqrt

prices = yf.download(TICKERS, period="3y") #downlaod data of 3yrs
prices = prices.xs('Close', axis=1, level=0)
# TO DO :Clean missing values using dropna and fillna
# prices =prices.fillna(0)
prices.tail(10)

TICKERS = ['RELIANCE.NS', 'TCS.NS', 'HDFCBANK.NS']  # you can change these take any 3 assets that are in yfinance
print("Selected assets:", TICKERS)

# TO DO : Simple Returns (Make sure to drop first row or NaN values as for first row we dont have any previous data)

simple_returns_hdfc =prices['HDFCBANK.NS']/prices['HDFCBANK.NS'].shift(1) - 1
simple_returns_tcs =prices['TCS.NS']/prices['TCS.NS'].shift(1) - 1
simple_returns_reliance =prices['RELIANCE.NS']/prices['RELIANCE.NS'].shift(1) - 1
simple_returns = pd.DataFrame([simple_returns_hdfc,simple_returns_reliance,simple_returns_tcs])
simple_returns = simple_returns.T
simple_returns=simple_returns.dropna()


# TO DO : Log Returns (Make sure to drop first row or NaN values as for first row we dont have any previous data)
log_returns_hdfc = np.log(prices['HDFCBANK.NS']/prices['HDFCBANK.NS'].shift(1))
log_returns_tcs = np.log(prices['TCS.NS']/prices['TCS.NS'].shift(1))
log_returns_reliance = np.log(prices['RELIANCE.NS']/prices['RELIANCE.NS'].shift(1))
log_returns = pd.DataFrame([log_returns_hdfc,log_returns_reliance,log_returns_tcs])
log_returns = log_returns.T
log_returns=log_returns.dropna()

print("\nSimple Returns :")
display(simple_returns.head(10))

print("\nLog Returns :")
display(log_returns.head(10))

from logging import log
TRADING_DAYS = 252

# TO DO : Annual expected return (mean log return × 252)
expected_return =log_returns.mean()*TRADING_DAYS

# TO DO : Annualized volatility (std of returns × sqrt(252))
volatility =log_returns.std()*sqrt(TRADING_DAYS)

print("\n Annualized Expected Return")
display(expected_return)

print("\n Annualized Volatility (Risk)")
display(volatility)

# TO DO : Covariance (annualized)- first find daily covariance (using log return) and then find the annual covariance
cov_daily =log_returns.cov()
cov_annual =log_returns.cov()*TRADING_DAYS

# TO DO : Correlation matrix
corr =log_returns.corr()

print("\n Covariance Matrix (Annualized) ")
display(cov_annual)

print("\n Correlation Matrix ")
display(corr)

#Visualization
norm_prices = prices / prices.iloc[0] * 100
plt.figure(figsize=(12,6))
for col in norm_prices.columns:
    plt.plot(norm_prices.index, norm_prices[col], label=col)

plt.title("Normalized Prices (Start = 100)")
plt.ylabel("Normalized Value")
plt.xlabel("Date")
plt.legend()
plt.show()

# 2) Correlation Heatmap
plt.figure(figsize=(7,5))
sns.heatmap(corr, annot=True, cmap="coolwarm", vmin=-1, vmax=1)
plt.title("Correlation Matrix")
plt.show()

# 3) Risk vs Return Scatter
plt.figure(figsize=(7,5))
plt.scatter(volatility, expected_return, s=120)

for t in TICKERS:
    plt.text(volatility[t]*1.01, expected_return[t]*1.01, t, fontsize=11)

plt.xlabel("Annualized Volatility (Risk)")
plt.ylabel("Annualized Expected Return")
plt.title("Risk vs Return")
plt.grid(True)
plt.show()

"""**Asset with highest expexted return:** *RELIANCE.NS*
<br>
**Asset with highest Volatility:** *RELIANCE.NS*
<br>
**No negatively correlated pair.**
"""