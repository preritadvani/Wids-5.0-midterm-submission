# -*- coding: utf-8 -*-
"""FinalProject_25B4538

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1o2FkMirR6EFM3ORH4MzkKx0PpZFIgWh9
"""

import pandas as pd
import cvxpy as cp
import numpy as np
import yfinance as yf
import matplotlib.pyplot as plt
import seaborn as sns
from math import sqrt

TICKERS = []
n=int(input("Enter number of elements : "))
for i in range(0, n):
  TICKERS.append(str(input("Input i+1: "))+".NS")
df = yf.download(TICKERS, period="3y")
prices = df.xs("Close", axis=1, level=0)

prices = prices.fillna(method="ffill").dropna()
prices.head()

log_returns = np.log(prices / prices.shift(1))
log_returns = log_returns.dropna()
# log_returns = log_returns.T
log_returns.head()

from logging import log
TRADING_DAYS = 252

# TO DO : Annual expected return (mean log return × 252)
expected_return =log_returns.mean()*TRADING_DAYS

# TO DO : Annualized volatility (std of returns × sqrt(252))
volatility =log_returns.std()*sqrt(TRADING_DAYS)

print("\n Annualized Expected Return")
display(expected_return)

print("\n Annualized Volatility (Risk)")
display(volatility)

# TO DO : Covariance (annualized)- first find daily covariance (using log return) and then find the annual covariance
cov_daily =log_returns.cov()
cov_annual =log_returns.cov()*TRADING_DAYS

# TO DO : Correlation matrix
corr =log_returns.corr()

print("\n Covariance Matrix (Annualized) ")
display(cov_annual)

print("\n Correlation Matrix ")
display(corr)

from cvxpy.settings import LEQ
from cvxpy.problems.objective import Maximize
mu = np.array(expected_return).reshape(n,1)
Sigma = cov_annual.values
w= cp.Variable((n, 1))
L= float(input('Enter the risk tolerance: '))
# R= float(input('Enter minimum expected logreturn: '))
#  #expected logreturn
# constraints = [cp.sum(w) == 1, w>=0, mu.T@w>=R]
constraints = [cp.sum(w) == 1, w>=0]

# objective = cp.Minimize(cp.quad_form(w, Sigma))
objective = cp.Maximize(mu.T@w-L*cp.quad_form(w, Sigma))
problem = cp.Problem(objective, constraints)
problem.solve()
# print('The portfolio that gives the return R at the minimum possible risk is:\n',w.value.T)
print('The optimal portfolio weights for the given risk tolerance is: \n',w.value.T)
var = (w.value.T)@(Sigma)@(w.value)
print('The stdev of this portfolio is: ',np.sqrt(var))
print('The Expected return of this portfolio is: ', mu.T@w.value)

l_values = np.linspace(0.1, 10, 100)
print("Generated L values:")
print(l_values[:5])

optimal_weights=[]
for L in l_values:
    w= cp.Variable((n, 1))
    constraints = [cp.sum(w) == 1, w>=0]
    objective = cp.Maximize(mu.T@w - L*cp.quad_form(w, Sigma))
    problem = cp.Problem(objective, constraints)
    problem.solve()
    if problem.status == cp.OPTIMAL or problem.status == cp.OPTIMAL_INACCURATE:
        optimal_weights.append(w.value.flatten())
    else:
        optimal_weights.append(np.full(n, np.nan))

optimal_weights = np.array(optimal_weights)
print(optimal_weights)

plt.figure(figsize=(12, 6))
for i in range(optimal_weights.shape[1]):
    plt.plot(l_values, optimal_weights[:, i], label=TICKERS[i])

plt.xlabel('Risk Tolerance (L)')
plt.ylabel('Optimal Weight')
plt.title('Optimal Portfolio Weights vs. Risk Tolerance')
plt.legend()
plt.grid(True)
plt.show()

# Lists to store portfolio returns and volatility
portfolio_returns = []
portfolio_volatility = []


# Loop over every feasible portfolio weight vector
for w in optimal_weights:
    ret =(mu.T)@w                    # TO DO : Calculate return of Portfolio
    var = (w.T)@(log_returns.cov())@(w)                        # TO DO : Calculate Volatility

    portfolio_returns.append(ret)
    portfolio_volatility.append(np.sqrt(var))

portfolio_df = pd.DataFrame(optimal_weights, columns=["w1", "w2", "w3"])
portfolio_df["Return"] = portfolio_returns
portfolio_df["Volatility"] = portfolio_volatility

portfolio_df.head()

plt.figure(figsize=(8,6))
plt.scatter(portfolio_df["Volatility"], portfolio_df["Return"], alpha=0.2)
plt.plot(portfolio_volatility,portfolio_returns, color="red", linewidth=2)
plt.xlabel("Volatility")
plt.ylabel("Expected Return")
print('The effecient frontier consisting of optimal portfolios for several risk tolerances:')
plt.show()